# VESPER_CUDA

VESPER is a computational tool using local vector based algorithm that can accurately identify the global and local
alignment of cryo-electron microscopy (EM) maps.

VESPER_CUDA is the CUDA accelerated version of VESPER reimplemented in Python.

VESPER Repo: https://github.com/kiharalab/VESPER \
<!-- Data: https://drive.google.com/drive/folders/1os3i7YmlMew3dmfovlzRU4WVuJ7nKzPX?usp=sharing -->

# Installation:

Choose one of the following methods to install the python environment for VESPER_CUDA.

## VirtualEnv

Please use Python 3.9 or higher. Chek your Python version using the following command:

```
python3 --version
```

Create a python venv and activate it before installing the requirements:

```
# for Linux
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

```
# for Windows
python3 -m venv venv
venv\Scripts\activate
pip install -r requirements.txt
```

Install PyTorch for CUDA acceleration (Optional):

```
pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
```

## Conda Environment

Create a conda environment using the YAML file in the repository (Includes PyTorch for CUDA acceleration):

```
conda env create -f environment.yml
conda activate vesper_cuda
```

<!-- # VESPER_Python protocol

VESPER_Python uses vector based algorithm same as the previous version and along with that it also uses secondary structure mapping in deciding the best superimposition between two maps.

The secondary structure mapping is done with the help of Emap2sec+. Emap2sec+ gives the probability of the secondary structure of each voxel of the input mrc map.

These probabilities are used to make probability mrc maps which contain the probabilities of each structure. -->


<!-- # Probability Map Generation Pipeline
Using secondary structure matching requires probability predictions generated by Emap2sec+ at each voxel. To generate the two probability map files required, follow the process below:
1. Run Emap2sec+ modes 5 and 6 to generate a .npy file.
2. Run the interpolation script using the following command. The interpolation script has two modes: insert and graph </br>
a. insert: only interpolates the map given. </br>
```
Usage: interpolation.py insert [-h] -f F -s S
---Options---
-h, --help  show this help message and exit
  -f F        Map array (.npy)
  -s S        Name for new map to be saved (string)
```
b. graph: interpolates the given map and saves each secondary structure prediction map individually.
```
Usage: interpolation.py graph [-h] -f F -s S -m M
---Options---
-h, --help  show this help message and exit
  -f F        Map array (.npy)
  -s S        Name for individual maps (string)
  -m M        Name of density map file. NOTE: VOXEL SPACIING MUST BE 1. (.mrc)
```
 -->

## Usage

(1) Mode 1: No additional file generation is required. Only the maps used for matching are needed to run the program. (
No secondary structure matching.)

```
Usage: main.py orig [-h] -a A -b B [-t T] [-T T] [-g G] [-s S] [-A A] [-N N] [-S S] [-M M] [-E E]
---Options---
-h, --help  show this help message and exit
  -a {MAP1 Path}            MAP1.mrc (large)
  -b {MAP2 Path}            MAP2.mrc (small)
  -t {MAP1 Threshold}       Threshold of density map1
  -T {MAP2 Threshold}       Threshold of density map2
  -g {G}                    Bandwidth of the Gaussian filter sigma = 0.5 * G, def=16.0
  -s {Voxel Spacing}        Sampling voxel spacing def=7.0
  -A {Angle Spacing}        Sampling angle spacing def=30.0
  -N {Number}               Refine Top [int] models def=10
  -S                        Show topN models vector representation in PDB format, def=false
  -M {Mode}                 V: Vector Product mode (Default)
                            O: Overlap mode
                            C: Cross Correlation Coefficient
                            P: Pearson Correlation Coefficient
                            L: Laplacian Filtering mode
  -E                        Evaluation mode of the current position, def=false
  -o {Output Path}          Output path for the results, def=results
  -gpu {GPUID}              GPU ID to use, if not present, use CPU
  -nodup                    Remove duplicate positions using heuristics (Optional)
  -pdbin                    Input PDB file for transformation (Optional)
  -ca {Backbone PDB Path}   Query map CA atoms in PDB format for LDP recall reranking only (Optional)
  -ldp {LDP PDB Path}       Local dense point representation for LDP recall reranking only (Optional)
  -c {Thread Count}         Number of threads to use, def=2
```

(2) Mode 2: Probability maps generated for each secondary structure in both maps used for alignment must be generated
using Emap2sec+ first and then converted into .npy format using the interpolation script before running this mode. (With
Secondary structure matching.)

```
Usage: main.py prob [-h] -a A -npa NPA -b B -npb NPB [-t T] [-T T] [-g G] [-s S] [-A A] [-N N] [-S S] [-M M] [-E E]
[-vav VAV] [-vstd VSTD] [-pav PAV] [-pstd PSTD]
---Options---
 -h, --help  show this help message and exit
  -a A          MAP1.mrc (large)
  -npa NPA      Numpy array for Predictions for map 1
  -b B          MAP2.mrc (small)
  -npb NPB      Numpy array for Predictions for map 2
  -alpha ALPHA  The weighting parameter
  -t T          Threshold of density map1
  -T T          Threshold of density map2
  -g G          Bandwidth of the Gaussian filter def=16.0, sigma = 0.5*[value entered]
  -s S          Sampling voxel spacing def=7.0
  -A A          Sampling angle spacing def=30.0
  -N N          Refine Top [int] models def=10
  -S S          Show topN models in PDB format def=false
  -M M          V: vector product mode (default)
                O: overlap mode
                C: Cross Correlation Coefficient Mode
                P: Pearson Correlation Coefficient Mode
                L: Laplacian Filtering Mode
  -E E          Evaluation mode of the current position def=false
  -vav VAV      Pre-computed average for density map
  -vstd VSTD    Pre-computed standard deviation for density map
  -pav PAV      Pre-computed average for probability map
  -pstd PSTD    Pre-computed standard deviation for probability map
```

## Identify the best fitting of two EM maps.

Run VESPER in either probability or original mode.

#### Output Format:

By default, VESPER_python writes the vector information for each of top 10 models after local refinement into VESPER
output. Vector information for the first model starts with two lines like the ones shown below.

```
Overlap= 0.02156028368794326 76/3525 CC= 0.012639913 PCC= -0.09214708 Scoreplusprob= 0.00019255988782371103 Scoreprobonly= 3.5619823131948194e-05
Score=  58.680508
```

Score shows the DOT score, which is the summation of dot products of matched vectors between two maps. Scoreplusprob
shows the normalized score which is the sum of the normalized dot score as well as the normalized probability dot score.
Scoreprobonly represents only the normalized probability dot score.

## Visualizing the transformed positions of the query maps.

<!-- VESPER_Python gives the pdb files of the top 10 alignments. They are named as "model_x.pdb". These are the query maps transformed to the best alignment position according to VESPER_Python. These can be visualised using PyMol or Chimera. -->

